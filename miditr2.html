<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChasmTracker - Web MIDI Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', 'Consolas', monospace;
            background: #000;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background: #1a1a1a;
            padding: 5px 10px;
            border-bottom: 2px solid #333;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .logo {
            height: 50px;
            display: flex;
            align-items: center;
            margin-right: 10px;
        }

        .logo svg {
            height: 100%;
            width: auto;
        }

        .header-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .header label {
            font-size: 12px;
            color: #aaa;
        }

        .header input, .header select, .header button {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #fff;
            padding: 5px 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .header button {
            cursor: pointer;
            min-width: 60px;
        }

        .header button:hover {
            background: #3a3a3a;
        }

        .header button.active {
            background: #4a4a4a;
        }

        .pattern-editor-container {
            flex: 1;
            overflow: auto;
            position: relative;
        }

        .pattern-editor {
            border-collapse: collapse;
            font-family: 'Courier New', 'Consolas', monospace;
            font-size: 13px;
            width: max-content;
            min-width: 100%;
        }

        .pattern-editor th {
            background: #1a1a1a;
            position: sticky;
            top: 0;
            z-index: 10;
            padding: 5px;
            border: 1px solid #333;
            text-align: center;
            font-weight: normal;
        }

        .pattern-editor th.row-header {
            width: 40px;
            background: #1a1a1a;
            color: #666;
        }

        .pattern-editor th.channel-header {
            background: #2a2a2a;
            color: #fff;
            min-width: 70px;
        }

        .pattern-editor th.channel-header.even {
            background: #2a2a2a;
        }

        .pattern-editor th.channel-header.odd {
            background: #252525;
        }

        .pattern-editor td.cell.even {
            background: #1a1a1a;
        }

        .pattern-editor td.cell.odd {
            background: #151515;
        }

        .pattern-editor td {
            border: 1px solid #222;
            padding: 0;
            height: 20px;
        }

        .pattern-editor td.row-number {
            background: #1a1a1a;
            color: #666;
            text-align: right;
            padding: 0 5px;
            width: 40px;
            font-size: 11px;
            position: sticky;
            left: 0;
            z-index: 12;
        }

        .pattern-editor td.cell {
            background: #1a1a1a; /* Default (even), will be overridden by .odd */
            padding: 0;
            cursor: text;
        }

        .pattern-editor td.cell.even:hover {
            background: #2a2a2a;
        }

        .pattern-editor td.cell.odd:hover {
            background: #202020;
        }

        .pattern-editor td.cell.active {
            background: #004080 !important;
            border: 1px solid #0066cc;
        }

        .pattern-editor td.cell.playing {
            background: #400040 !important;
            border: 1px solid #800080;
        }

        .pattern-editor td.cell.active.playing {
            background: #404080 !important;
            border: 1px solid #6666cc;
        }

        .cell-content {
            display: flex;
            height: 100%;
        }

        .cell-field {
            flex: 1;
            padding: 2px 3px;
            border: none;
            background: transparent;
            color: #fff;
            font-family: 'Courier New', 'Consolas', monospace;
            font-size: 12px;
            outline: none;
            width: 100%;
        }

        .cell-field:focus {
            background: rgba(255, 255, 255, 0.1);
        }

        .note-field {
            width: 30px;
            text-align: center;
        }

        .vol-field {
            width: 20px;
            text-align: center;
        }

        .eff-field, .param-field {
            width: 20px;
            text-align: center;
        }

        .sidebar {
            width: 200px;
            background: #1a1a1a;
            border-left: 2px solid #333;
            padding: 10px;
            overflow-y: auto;
            font-size: 11px;
        }

        .sidebar-section {
            margin-bottom: 20px;
        }

        .sidebar-title {
            color: #aaa;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .pattern-order {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .pattern-order-item {
            background: #2a2a2a;
            padding: 5px 10px;
            cursor: pointer;
            border: 1px solid #444;
        }

        .pattern-order-item.active {
            background: #4a4a4a;
            border-color: #666;
        }


        .status {
            padding: 5px;
            background: #2a2a2a;
            border: 1px solid #444;
            margin-top: 10px;
        }


        .help {
            margin-top: 20px;
            font-size: 10px;
            color: #666;
        }

        .help-key {
            display: inline-block;
            background: #2a2a2a;
            padding: 2px 5px;
            border: 1px solid #444;
            margin: 2px;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .editor-wrapper {
            flex: 1;
            overflow: auto;
            position: relative;
        }

        /* Instrument Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            overflow: auto;
        }

        .modal-content {
            background-color: #1a1a1a;
            margin: 50px auto;
            padding: 20px;
            border: 2px solid #444;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            font-family: 'Courier New', 'Consolas', monospace;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #333;
        }

        .modal-title {
            font-size: 18px;
            color: #fff;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            width: 30px;
            height: 30px;
        }

        .close:hover {
            color: #fff;
        }

        .instrument-list {
            margin-bottom: 20px;
        }

        .instrument-item {
            background: #2a2a2a;
            border: 1px solid #444;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .instrument-item:hover {
            background: #3a3a3a;
        }

        .instrument-item.active {
            background: #004080;
            border-color: #0066cc;
        }

        .instrument-params {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #333;
        }

        .param-group {
            margin-bottom: 15px;
        }

        .param-group label {
            display: block;
            color: #aaa;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .param-group input[type="range"] {
            width: 100%;
        }

        .param-group select {
            width: 100%;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #fff;
            padding: 5px;
            font-family: 'Courier New', monospace;
        }

        .param-value {
            display: inline-block;
            color: #4caf50;
            margin-left: 10px;
            font-weight: bold;
        }

        .instrument-actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        .instrument-actions button {
            padding: 8px 15px;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #fff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        .instrument-actions button:hover {
            background: #3a3a3a;
        }

        /* Toast notification */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #2a2a2a;
            border: 1px solid #666;
            color: #fff;
            padding: 12px 20px;
            border-radius: 4px;
            font-family: 'Courier New', 'Consolas', monospace;
            font-size: 13px;
            z-index: 10000;
            opacity: 0;
            transform: translateX(100%);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
        }

        .toast.fade-out {
            opacity: 0;
            transform: translateX(100%);
        }

        .pattern-quick-switch {
            display: flex;
            gap: 2px;
        }

        .pattern-quick-btn {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #fff;
            padding: 3px 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            cursor: pointer;
            min-width: 30px;
        }

        .pattern-quick-btn:hover {
            background: #3a3a3a;
        }

        .pattern-quick-btn.active {
            background: #004080;
            border-color: #0066cc;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 80" width="400" height="80">
                    <defs>
                        <linearGradient id="chasmGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#0066cc;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#4a90e2;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#0066cc;stop-opacity:1" />
                        </linearGradient>
                        <linearGradient id="trackerGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color:#888;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#fff;stop-opacity:1" />
                        </linearGradient>
                        <filter id="glow">
                            <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                    
                    <!-- Background chasm effect -->
                    <rect x="0" y="0" width="400" height="80" fill="#000"/>
                    
                    <!-- Chasm depth lines -->
                    <path d="M 0 40 L 100 20 L 200 35 L 300 25 L 400 40" 
                          stroke="#0066cc" 
                          stroke-width="2" 
                          fill="none" 
                          opacity="0.3"/>
                    <path d="M 0 50 L 100 30 L 200 45 L 300 35 L 400 50" 
                          stroke="#0066cc" 
                          stroke-width="1.5" 
                          fill="none" 
                          opacity="0.2"/>
                    
                    <!-- Main "CHASM" text with 3D effect -->
                    <text x="20" y="50" 
                          font-family="'Courier New', 'Consolas', monospace" 
                          font-size="42" 
                          font-weight="bold" 
                          fill="url(#chasmGradient)"
                          filter="url(#glow)"
                          letter-spacing="2">CHASM</text>
                    
                    <!-- "TRACKER" text -->
                    <text x="20" y="70" 
                          font-family="'Courier New', 'Consolas', monospace" 
                          font-size="18" 
                          fill="url(#trackerGradient)"
                          letter-spacing="4">TRACKER</text>
                    
                    <!-- Musical note accent -->
                    <g transform="translate(320, 20)">
                        <!-- Note head -->
                        <ellipse cx="0" cy="20" rx="6" ry="8" fill="#4a90e2"/>
                        <ellipse cx="0" cy="20" rx="4" ry="6" fill="#0066cc"/>
                        
                        <!-- Note stem -->
                        <rect x="4" y="0" width="2" height="20" fill="#4a90e2"/>
                        
                        <!-- Note flag -->
                        <path d="M 6 0 Q 12 -4 14 0 Q 12 4 6 0" fill="#4a90e2"/>
                    </g>
                    
                    <!-- Pattern grid accent (tracker style) -->
                    <g transform="translate(350, 45)" opacity="0.4">
                        <rect x="0" y="0" width="3" height="3" fill="#4a90e2"/>
                        <rect x="4" y="0" width="3" height="3" fill="#4a90e2"/>
                        <rect x="8" y="0" width="3" height="3" fill="#4a90e2"/>
                        <rect x="0" y="4" width="3" height="3" fill="#0066cc"/>
                        <rect x="4" y="4" width="3" height="3" fill="#4a90e2"/>
                        <rect x="8" y="4" width="3" height="3" fill="#0066cc"/>
                        <rect x="0" y="8" width="3" height="3" fill="#4a90e2"/>
                        <rect x="4" y="8" width="3" height="3" fill="#0066cc"/>
                        <rect x="8" y="8" width="3" height="3" fill="#4a90e2"/>
                    </g>
                </svg>
            </div>
            <div class="header-group">
                <button id="playBtn">Play</button>
                <button id="stopBtn">Stop</button>
            </div>
            <div class="header-group">
                <label>Mode</label>
                <select id="playModeSelect" style="width: 100px;">
                    <option value="song">Song</option>
                    <option value="pattern">Pattern</option>
                </select>
            </div>
            <div class="header-group">
                <label>BPM</label>
                <input type="number" id="bpmInput" value="125" min="32" max="255" style="width: 60px;">
            </div>
            <div class="header-group">
                <label>Octave</label>
                <input type="number" id="octaveInput" value="4" min="0" max="9" style="width: 50px;">
            </div>
            <div class="header-group">
                <label>Pattern</label>
                <input type="number" id="patternInput" value="0" min="0" style="width: 60px;">
            </div>
            <div class="header-group">
                <label>Length</label>
                <input type="number" id="patternLengthInput" value="64" min="1" max="256" style="width: 60px;">
            </div>
            <div class="header-group">
                <label>Step</label>
                <input type="number" id="stepSizeInput" value="1" min="1" max="64" style="width: 50px;">
            </div>
        </div>

        <div class="main-content">
            <div class="editor-wrapper">
                <div class="pattern-editor-container">
                    <table class="pattern-editor" id="patternTable">
                        <thead id="patternHeader"></thead>
                        <tbody id="patternBody"></tbody>
                    </table>
                </div>
            </div>
            <div class="sidebar">
                <div class="sidebar-section">
                    <div class="sidebar-title">Pattern Order</div>
                    <div class="pattern-order" id="patternOrder"></div>
                </div>
                <div class="sidebar-section">
                    <div class="sidebar-title">Info</div>
                    <div>Step: <span id="currentStep">0</span></div>
                </div>
                <div class="sidebar-section">
                    <button id="addPatternBtn" style="width: 100%; padding: 5px;">Add Pattern</button>
                </div>
                <div class="sidebar-section help">
                    <div class="sidebar-title">Shortcuts</div>
                    <div><span class="help-key">Space</span> or <span class="help-key">P</span> Play/Stop</div>
                    <div><span class="help-key">S</span> Stop</div>
                    <div><span class="help-key">↑↓←→</span> Navigate (uses step size)</div>
                    <div><span class="help-key">Enter</span> Step down (uses step size)</div>
                    <div><span class="help-key">Tab</span> Next channel</div>
                    <div><span class="help-key">Del</span> or <span class="help-key">Backspace</span> Clear cell (moves to next row)</div>
                    <div><span class="help-key">.</span> Delete current field</div>
                    <div><span class="help-key">§</span> Note off (==)</div>
                    <div><span class="help-key">Ctrl+C/V</span> Copy/Paste</div>
                    <div><span class="help-key">Ctrl+1-8</span> Switch pattern</div>
                    <div><span class="help-key">Ctrl+←→</span> Prev/Next pattern</div>
                    <div><span class="help-key">QWERTY</span> Note entry</div>
                    <div><span class="help-key">0-9</span> Set octave</div>
                    <div><span class="help-key">/</span> <span class="help-key">*</span> Decrease/Increase Octave</div>
                    <div><span class="help-key">Alt+1-9</span> Set step size</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>

    <!-- Program Change Modal -->
    <div id="programChangeModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Program Change - MIDI Channel <span id="programChangeChannel">0</span></div>
                <button class="close" onclick="closeProgramChangeModal()">&times;</button>
            </div>
            <div style="padding: 20px;">
                <div class="param-group">
                    <label>Program (0-127):</label>
                    <input type="number" id="programChangeInput" value="0" min="0" max="127" style="width: 100%; background: #2a2a2a; border: 1px solid #444; color: #fff; padding: 8px; font-family: 'Courier New', monospace;">
                </div>
                <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="applyProgramChange()" style="padding: 8px 16px; cursor: pointer; background: #2a2a2a; border: 1px solid #444; color: #fff; font-family: 'Courier New', monospace;">Apply</button>
                    <button onclick="closeProgramChangeModal()" style="padding: 8px 16px; cursor: pointer; background: #2a2a2a; border: 1px solid #444; color: #fff; font-family: 'Courier New', monospace;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script src="midi-synths.js"></script>
    <script>
        // State management
        const state = {
            patterns: [],
            currentPattern: 0,
            currentStep: 0,
            isPlaying: false,
            bpm: 125,
            channels: 16, // Number of tracks (can be up to 64, but only 16 displayed)
            order: [0],
            midiManager: null,
            midiAccess: null,
            midiOutput: null,
            activeCell: { row: 0, channel: 0, field: 'note' },
            clipboard: null,
            activeNotes: new Map(), // Track active MIDI notes per channel
            lastTickTime: 0,
            lastMidiClockTime: 0,
            midiClockCounter: 0,
            midiClockTimer: null,
            stepTimer: null,
            scheduledMidiClockTime: 0,
            scheduledStepTime: 0,
            maxChannels: 256, // Maximum channels like Schism Tracker
            currentOctave: 4, // Default octave for note entry
            noteEntryBuffer: '', // Buffer for note entry (e.g., "C#4")
            patternLength: 64, // Pattern length in rows
            playbackMode: 'song', // 'song' or 'pattern'
            stepSize: 1, // Step size for up/down navigation
            trackMidiChannels: [], // Map track index to MIDI channel (0-15)
            midiProgramChanges: {}, // Map MIDI channel (0-15) to program number (0-127)
            trackNames: [] // Track display names (e.g., "1", "2", "4b", "4c")
        };

        // QWERTY keyboard to note mapping (Schism Tracker style)
        // Bottom row (Z row): Z=C, S=C#, X=D, D=D#, C=E, V=F, G=F#, B=G, H=G#, N=A, J=A#, M=B
        // Top row (Q row): Q=C, 2=C#, W=D, 3=D#, E=E, R=F, 5=F#, T=G, 6=G#, Y=A, 7=A#, U=B
        // I row: I=C, 9=C#, O=D, 0=D#, P=E, [=F, = (equals) =F#, ]=G
        const qwertyNoteMap = {
            // Bottom row (Z row) - base octave
            'z': 'C', 's': 'C#', 'x': 'D', 'd': 'D#', 'c': 'E', 'v': 'F', 'g': 'F#', 'b': 'G', 'h': 'G#', 'n': 'A', 'j': 'A#', 'm': 'B',
            // Top row (Q row) - one octave up
            'q': 'C', '2': 'C#', 'w': 'D', '3': 'D#', 'e': 'E', 'r': 'F', '5': 'F#', 't': 'G', '6': 'G#', 'y': 'A', '7': 'A#', 'u': 'B',
            // I row - two octaves up
            'i': 'C', '9': 'C#', 'o': 'D', '0': 'D#', 'p': 'E', '[': 'F', '=': 'F#', ']': 'G'
        };

        // Note name mapping
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const noteNameMap = {
            'C': 0, 'C#': 1, 'DB': 1, 'D': 2, 'D#': 3, 'EB': 3,
            'E': 4, 'F': 5, 'F#': 6, 'GB': 6, 'G': 7, 'G#': 8, 'AB': 8,
            'A': 9, 'A#': 10, 'BB': 10, 'B': 11
        };

        // Initialize first pattern
        function initPattern(patternIndex = null) {
            const idx = patternIndex !== null ? patternIndex : state.patterns.length;
            if (state.patterns[idx]) {
                // Pattern exists, just ensure it has correct number of channels and length
                resizePattern(idx);
                return;
            }
            const pattern = {
                channels: []
            };
            // Always create at least 16 channels
            const minChannels = Math.max(state.channels, 16);
            for (let ch = 0; ch < minChannels; ch++) {
                const channel = [];
                for (let row = 0; row < state.patternLength; row++) {
                    channel.push({
                        note: '',
                        inst: '',
                        vol: '',
                        effect: '',
                        param: ''
                    });
                }
                pattern.channels.push(channel);
                // Initialize MIDI channel mapping: track maps to its own MIDI channel by default
                if (!state.trackMidiChannels[ch]) {
                    state.trackMidiChannels[ch] = Math.min(ch, 15);
                }
                // Initialize track name
                if (!state.trackNames[ch]) {
                    state.trackNames[ch] = String(ch + 1);
                }
            }
            // Update state.channels to ensure it's at least 16
            if (state.channels < 16) {
                state.channels = 16;
            }
            state.patterns[idx] = pattern;
        }

        // Resize pattern to current patternLength
        function resizePattern(patternIndex) {
            const pattern = state.patterns[patternIndex];
            if (!pattern) return;

            for (let ch = 0; ch < pattern.channels.length; ch++) {
                const channel = pattern.channels[ch] || [];
                const currentLength = channel.length;
                
                if (currentLength < state.patternLength) {
                    // Add empty steps
                    for (let row = currentLength; row < state.patternLength; row++) {
                        channel.push(createEmptyStep());
                    }
                } else if (currentLength > state.patternLength) {
                    // Remove excess steps
                    channel.splice(state.patternLength);
                }
            }
        }

        // Resize all patterns to current patternLength
        function resizeAllPatterns() {
            for (let i = 0; i < state.patterns.length; i++) {
                resizePattern(i);
            }
        }

        // Create empty step
        function createEmptyStep() {
            return {
                note: '',
                vol: ''
            };
        }

        // Initialize first pattern with 16 channels
        initPattern(0);


        // MIDI Functions using MidiManager
        async function requestMIDIAccess() {
            if (!state.midiManager) {
                state.midiManager = new MidiManager();
            }
            
            const success = await state.midiManager.initialize();
            if (success) {
                // Auto-connect to first available device
                const devices = state.midiManager.getDevices();
                if (devices.length > 0) {
                    state.midiManager.connect(0);
                    state.midiOutput = state.midiManager.midiOutput;
                }
                return true;
            } else {
                console.warn('MIDI not available');
                return false;
            }
        }

        function sendMIDINote(trackIndex, note, velocity, on = true) {
            if (!state.midiManager || !state.midiManager.midiOutput) return;
            
            // Validate and clamp note to valid MIDI range (0-127)
            if (note === null || note === undefined || isNaN(note)) return;
            const clampedNote = Math.max(0, Math.min(127, Math.round(note)));
            
            // Validate and clamp velocity to valid MIDI range (0-127)
            if (velocity === null || velocity === undefined || isNaN(velocity)) return;
            const clampedVelocity = Math.max(0, Math.min(127, Math.round(velocity)));
            
            // Get MIDI channel for this track (default to track index if not mapped)
            const midiChannel = state.trackMidiChannels[trackIndex] !== undefined 
                ? Math.min(state.trackMidiChannels[trackIndex], 15)
                : Math.min(trackIndex, 15);
            const status = on ? 0x90 : 0x80;
            state.midiManager.midiOutput.send([status + midiChannel, clampedNote, clampedVelocity]);
        }

        function sendMIDIProgramChange(midiChannel, program) {
            if (!state.midiManager || !state.midiManager.midiOutput) return;
            const channel = Math.max(0, Math.min(15, midiChannel));
            const prog = Math.max(0, Math.min(127, program));
            state.midiManager.midiOutput.send([0xC0 + channel, prog]);
        }

        function sendMIDICC(channel, cc, value) {
            if (!state.midiManager || !state.midiManager.midiOutput) return;
            
            const midiChannel = Math.min(channel, 15);
            state.midiManager.midiOutput.send([0xB0 + midiChannel, cc, value]);
        }

        // MIDI Timing Clock (0xF8) - sent 24 times per quarter note
        function sendMIDIClock() {
            if (!state.midiManager || !state.midiManager.midiOutput) return;
            state.midiManager.midiOutput.send([0xF8]);
        }

        // MIDI Transport messages
        function sendMIDIStart() {
            if (!state.midiManager || !state.midiManager.midiOutput) return;
            state.midiManager.midiOutput.send([0xFA]); // Start
        }

        function sendMIDIStop() {
            if (!state.midiManager || !state.midiManager.midiOutput) return;
            state.midiManager.midiOutput.send([0xFC]); // Stop
        }

        function sendMIDIContinue() {
            if (!state.midiManager || !state.midiManager.midiOutput) return;
            state.midiManager.midiOutput.send([0xFB]); // Continue
        }

        // Toast notification function
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.remove('fade-out');
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.add('fade-out');
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 300);
            }, duration);
        }

        // Program Change Modal Functions
        // Modal keyboard handler (defined once, reused)
        let modalKeyHandler = null;

        function openProgramChangeModal() {
            const currentTrack = state.activeCell.channel;
            const midiChannel = state.trackMidiChannels[currentTrack] !== undefined 
                ? Math.min(state.trackMidiChannels[currentTrack], 15)
                : Math.min(currentTrack, 15);
            
            // MIDI channels are displayed as 1-16, not 0-15
            document.getElementById('programChangeChannel').textContent = midiChannel + 1;
            const currentProgram = state.midiProgramChanges[midiChannel] !== undefined 
                ? state.midiProgramChanges[midiChannel] 
                : 0;
            const input = document.getElementById('programChangeInput');
            input.value = currentProgram;
            const modal = document.getElementById('programChangeModal');
            modal.style.display = 'block';
            
            // Remove old handler if it exists
            if (modalKeyHandler) {
                modal.removeEventListener('keydown', modalKeyHandler, true);
            }
            
            // Create new keyboard handler
            modalKeyHandler = (e) => {
                // Stop all keyboard events from reaching the main handler when modal is open
                e.stopPropagation();
                
                if (e.key === 'Enter' && (e.target.id === 'programChangeInput' || e.target.tagName !== 'INPUT')) {
                    e.preventDefault();
                    applyProgramChange();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    closeProgramChangeModal();
                }
                // Allow typing in the input field
            };
            
            modal.addEventListener('keydown', modalKeyHandler, true);
            
            // Focus and select the input so keyboard input works
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
        }

        function closeProgramChangeModal() {
            const modal = document.getElementById('programChangeModal');
            modal.style.display = 'none';
            // Remove keyboard handler when closing
            if (modalKeyHandler) {
                modal.removeEventListener('keydown', modalKeyHandler, true);
                modalKeyHandler = null;
            }
        }

        function applyProgramChange() {
            const currentTrack = state.activeCell.channel;
            const midiChannel = state.trackMidiChannels[currentTrack] !== undefined 
                ? Math.min(state.trackMidiChannels[currentTrack], 15)
                : Math.min(currentTrack, 15);
            
            const program = parseInt(document.getElementById('programChangeInput').value) || 0;
            const clampedProgram = Math.max(0, Math.min(127, program));
            
            state.midiProgramChanges[midiChannel] = clampedProgram;
            
            // Send program change immediately
            sendMIDIProgramChange(midiChannel, clampedProgram);
            
            savePatternsToStorage();
            closeProgramChangeModal();
        }

        // Add track for current MIDI channel
        function addTrackForCurrentChannel() {
            // Limit to maximum 64 tracks
            if (state.channels >= 64) {
                showToast('Maximum 64 tracks allowed');
                return;
            }
            
            const currentTrack = state.activeCell.channel;
            const midiChannel = state.trackMidiChannels[currentTrack] !== undefined 
                ? Math.min(state.trackMidiChannels[currentTrack], 15)
                : Math.min(currentTrack, 15);
            
            // Find base track name (e.g., "4" from "4b" or "4c")
            const currentTrackName = state.trackNames[currentTrack] || String(currentTrack + 1);
            const baseMatch = currentTrackName.match(/^(\d+)([a-z]*)$/);
            const baseNumber = baseMatch ? baseMatch[1] : currentTrackName;
            const existingSuffix = baseMatch ? baseMatch[2] : '';
            
            // Find all tracks with the same base number to determine next suffix
            const sameBaseTracks = [];
            for (let i = 0; i < state.trackNames.length; i++) {
                const name = state.trackNames[i] || String(i + 1);
                if (name.startsWith(baseNumber)) {
                    sameBaseTracks.push({ index: i, name: name });
                }
            }
            
            // Determine next suffix (b, c, d, etc.) - single letter only
            let nextSuffix = 'b';
            if (existingSuffix) {
                // Current track already has a suffix, find the next single letter
                // Extract just the last letter if it's a multi-letter suffix
                const lastChar = existingSuffix[existingSuffix.length - 1];
                if (lastChar >= 'a' && lastChar < 'z') {
                    nextSuffix = String.fromCharCode(lastChar.charCodeAt(0) + 1);
                } else {
                    nextSuffix = 'b'; // Start over if we hit 'z'
                }
            } else {
                // Current track has no suffix, find the highest single-letter suffix
                const usedSuffixes = [];
                sameBaseTracks.forEach(t => {
                    const match = t.name.match(/^\d+([a-z]+)$/);
                    if (match) {
                        // Only consider single-letter suffixes
                        if (match[1].length === 1) {
                            usedSuffixes.push(match[1]);
                        }
                    }
                });
                
                if (usedSuffixes.length > 0) {
                    // Find the next available single letter
                    usedSuffixes.sort();
                    let nextChar = 'b';
                    for (let i = 0; i < usedSuffixes.length; i++) {
                        if (usedSuffixes[i] === nextChar) {
                            const charCode = nextChar.charCodeAt(0);
                            if (charCode < 'z'.charCodeAt(0)) {
                                nextChar = String.fromCharCode(charCode + 1);
                            } else {
                                // If we've used all letters, can't add more
                                showToast('Maximum suffix reached for this base number');
                                return;
                            }
                        } else {
                            break;
                        }
                    }
                    nextSuffix = nextChar;
                }
            }
            
            const newTrackName = baseNumber + nextSuffix;
            
            // Insert new track right after current track
            const newTrackIndex = currentTrack + 1;
            state.channels++;
            
            // Shift track names and MIDI channel mappings
            for (let i = state.channels - 1; i > newTrackIndex; i--) {
                state.trackNames[i] = state.trackNames[i - 1];
                state.trackMidiChannels[i] = state.trackMidiChannels[i - 1];
            }
            
            // Initialize the new track in all patterns
            state.patterns.forEach((pattern) => {
                const channel = [];
                for (let row = 0; row < state.patternLength; row++) {
                    channel.push(createEmptyStep());
                }
                pattern.channels.splice(newTrackIndex, 0, channel);
            });
            
            // Set new track properties
            state.trackNames[newTrackIndex] = newTrackName;
            state.trackMidiChannels[newTrackIndex] = midiChannel;
            
            // Re-render pattern
            renderPattern();
            
            // Move to the new track
            moveCell(state.activeCell.row, newTrackIndex, 'note');
            focusField(state.activeCell.row, newTrackIndex, 'note');
            
            savePatternsToStorage();
        }

        // Remove track with suffix (e.g., 4c, then 4b)
        function removeTrackWithSuffix() {
            const currentTrack = state.activeCell.channel;
            const currentTrackName = state.trackNames[currentTrack] || String(currentTrack + 1);
            
            // Check if current track has a suffix (like 4b, 4c)
            const baseMatch = currentTrackName.match(/^(\d+)([a-z]+)$/);
            if (!baseMatch) {
                // Current track has no suffix, find the highest suffix track with same base
                const baseNumber = currentTrackName.match(/^\d+/)?.[0] || currentTrackName;
                
                // Find all tracks with the same base number that have suffixes (check all tracks)
                const suffixTracks = [];
                for (let i = 0; i < state.channels; i++) {
                    const name = state.trackNames[i] || String(i + 1);
                    const match = name.match(/^(\d+)([a-z]+)$/);
                    if (match && match[1] === baseNumber) {
                        suffixTracks.push({ index: i, name: name, suffix: match[2] });
                    }
                }
                
                if (suffixTracks.length === 0) {
                    showToast('No additional tracks to remove');
                    return;
                }
                
                // Sort by suffix (reverse alphabetical to get highest first)
                suffixTracks.sort((a, b) => b.suffix.localeCompare(a.suffix));
                const trackToRemove = suffixTracks[0];
                
                // Remove the track with highest suffix
                removeTrack(trackToRemove.index);
            } else {
                // Current track has a suffix, remove it
                removeTrack(currentTrack);
            }
        }

        // Remove a specific track
        function removeTrack(trackIndex) {
            if (trackIndex < 0 || trackIndex >= state.channels) {
                return;
            }
            
            // Don't remove if it's the only track with this base number
            const trackName = state.trackNames[trackIndex] || String(trackIndex + 1);
            const baseMatch = trackName.match(/^(\d+)([a-z]*)$/);
            const baseNumber = baseMatch ? baseMatch[1] : trackName;
            
            // Count tracks with same base number (check all tracks, not just displayed ones)
            let sameBaseCount = 0;
            for (let i = 0; i < state.channels; i++) {
                const name = state.trackNames[i] || String(i + 1);
                if (name.startsWith(baseNumber)) {
                    sameBaseCount++;
                }
            }
            
            if (sameBaseCount <= 1) {
                showToast('Cannot remove the last track with this base number');
                return;
            }
            
            // Remove from all patterns
            state.patterns.forEach((pattern) => {
                pattern.channels.splice(trackIndex, 1);
            });
            
            // Remove from state arrays
            state.trackNames.splice(trackIndex, 1);
            state.trackMidiChannels.splice(trackIndex, 1);
            state.channels--;
            
            // Adjust active cell if needed
            if (state.activeCell.channel >= state.channels) {
                state.activeCell.channel = Math.max(0, state.channels - 1);
            }
            
            // Re-render pattern
            renderPattern();
            
            // Update focus
            moveCell(state.activeCell.row, state.activeCell.channel, state.activeCell.field);
            focusField(state.activeCell.row, state.activeCell.channel, state.activeCell.field);
            
            savePatternsToStorage();
        }

        // Pattern Storage Functions
        function savePatternsToStorage() {
            try {
                const patternData = {
                    patterns: state.patterns,
                    order: state.order,
                    currentPattern: state.currentPattern,
                    channels: state.channels, // Save actual channel count (may be > 16)
                    patternLength: state.patternLength,
                    bpm: state.bpm,
                    playbackMode: state.playbackMode,
                    stepSize: state.stepSize,
                    trackMidiChannels: state.trackMidiChannels,
                    midiProgramChanges: state.midiProgramChanges,
                    trackNames: state.trackNames,
                    currentOctave: state.currentOctave
                };
                localStorage.setItem('tracker3_patterns', JSON.stringify(patternData));
            } catch (error) {
                console.error('Error saving patterns:', error);
            }
        }

        function loadPatternsFromStorage() {
            try {
                const saved = localStorage.getItem('tracker3_patterns');
                if (saved) {
                    const patternData = JSON.parse(saved);
                    if (patternData.patterns && patternData.patterns.length > 0) {
                        state.patterns = patternData.patterns;
                        state.order = patternData.order || [0];
                        state.currentPattern = patternData.currentPattern || 0;
                        // Load track count (default to 16 if not present, max 64)
                        state.channels = Math.max(Math.min(patternData.channels || 16, 64), 16);
                        if (patternData.patternLength) {
                            state.patternLength = patternData.patternLength;
                            document.getElementById('patternLengthInput').value = state.patternLength;
                        }
                        if (patternData.bpm) {
                            state.bpm = patternData.bpm;
                            document.getElementById('bpmInput').value = state.bpm;
                        }
                        if (patternData.playbackMode) {
                            state.playbackMode = patternData.playbackMode;
                            document.getElementById('playModeSelect').value = state.playbackMode;
                        }
                        if (patternData.stepSize) {
                            state.stepSize = patternData.stepSize;
                            document.getElementById('stepSizeInput').value = state.stepSize;
                        }
                        if (patternData.trackMidiChannels) {
                            state.trackMidiChannels = patternData.trackMidiChannels;
                        }
                        if (patternData.midiProgramChanges) {
                            state.midiProgramChanges = patternData.midiProgramChanges;
                        }
                        if (patternData.trackNames) {
                            state.trackNames = patternData.trackNames;
                        }
                        if (patternData.currentOctave !== undefined) {
                            state.currentOctave = patternData.currentOctave;
                            updateOctaveDisplay();
                        }
                        // Ensure all loaded patterns have correct number of channels
                        state.patterns.forEach((pattern) => {
                            while (pattern.channels.length < state.channels) {
                                const channel = [];
                                for (let row = 0; row < state.patternLength; row++) {
                                    channel.push(createEmptyStep());
                                }
                                pattern.channels.push(channel);
                            }
                        });
                        // Initialize MIDI channel mappings and track names for any tracks that don't have them
                        for (let ch = 0; ch < state.channels; ch++) {
                            if (state.trackMidiChannels[ch] === undefined) {
                                state.trackMidiChannels[ch] = Math.min(ch, 15);
                            }
                            if (!state.trackNames[ch]) {
                                state.trackNames[ch] = String(ch + 1);
                            }
                        }
                        // Resize all patterns to current patternLength
                        resizeAllPatterns();
                        return true;
                    }
                }
            } catch (error) {
                console.error('Error loading patterns:', error);
            }
            return false;
        }

        // Update octave display
        function updateOctaveDisplay() {
            const display = document.getElementById('currentOctaveDisplay');
            const octaveInput = document.getElementById('octaveInput');
            if (display) {
                display.textContent = state.currentOctave;
            }
            if (octaveInput) {
                octaveInput.value = state.currentOctave;
            }
        }

        // Modal functions

        // Parse note string (C-4, C#3, etc.) to MIDI note number
        function parseNote(noteStr) {
            if (!noteStr || noteStr.trim() === '') return null;
            
            const match = noteStr.match(/^([A-G][#Bb]?)(-?)(\d+)$/);
            if (!match) return null;
            
            const [, noteName, , octave] = match;
            const noteNum = noteNameMap[noteName.toUpperCase()];
            if (noteNum === undefined) return null;
            
            const octaveNum = parseInt(octave);
            return (octaveNum + 1) * 12 + noteNum;
        }

        // Format MIDI note number to note string
        function formatNote(midiNote) {
            if (midiNote === null || midiNote === undefined) return '';
            const octave = Math.floor(midiNote / 12) - 1;
            const note = midiNote % 12;
            return noteNames[note] + octave;
        }

        // Get base channel number from track name (e.g., "4b" -> 4, "4c" -> 4, "5" -> 5)
        function getBaseChannelNumber(trackName) {
            const match = trackName.match(/^(\d+)/);
            return match ? parseInt(match[1]) : 1;
        }

        // Check if a channel number is even or odd
        function isChannelEven(channelNumber) {
            return channelNumber % 2 === 0;
        }

        // Render pattern editor
        function renderPattern() {
            // Ensure pattern exists
            if (!state.patterns[state.currentPattern]) {
                initPattern(state.currentPattern);
            }
            const pattern = state.patterns[state.currentPattern];
            if (!pattern) return;
            
            // Ensure pattern has at least 16 channels (Ch1-Ch16)
            const minChannels = Math.max(state.channels, 16);
            while (pattern.channels.length < minChannels) {
                const channel = [];
                for (let row = 0; row < state.patternLength; row++) {
                    channel.push(createEmptyStep());
                }
                pattern.channels.push(channel);
                // Initialize track name if missing
                const chIndex = pattern.channels.length - 1;
                if (!state.trackNames[chIndex]) {
                    state.trackNames[chIndex] = String(chIndex + 1);
                }
                // Initialize MIDI channel mapping if missing
                if (state.trackMidiChannels[chIndex] === undefined) {
                    state.trackMidiChannels[chIndex] = Math.min(chIndex, 15);
                }
            }

            const header = document.getElementById('patternHeader');
            const body = document.getElementById('patternBody');
            
            header.innerHTML = '';
            body.innerHTML = '';

            // Create header
            const headerRow = document.createElement('tr');
            const rowHeader = document.createElement('th');
            rowHeader.className = 'row-header';
            rowHeader.textContent = '';
            headerRow.appendChild(rowHeader);

            // Always display at least 16 channels (Ch1-Ch16), even if there are fewer tracks
            const displayChannels = Math.max(state.channels, 16);
            for (let ch = 0; ch < displayChannels; ch++) {
                const th = document.createElement('th');
                const trackName = state.trackNames[ch] || String(ch + 1);
                const baseChannel = getBaseChannelNumber(trackName);
                const isEven = isChannelEven(baseChannel);
                
                th.className = `channel-header ${isEven ? 'even' : 'odd'}`;
                // Make first 16 channels sticky
                if (ch < 16) {
                    th.style.position = 'sticky';
                    // Calculate left position: row number width (40px) + channel width (70px) * channel index
                    th.style.left = `${40 + (ch * 70)}px`;
                    th.style.zIndex = '11';
                }
                th.textContent = `Ch${trackName}`;
                headerRow.appendChild(th);
            }
            header.appendChild(headerRow);

            // Create rows
            for (let row = 0; row < state.patternLength; row++) {
                const tr = document.createElement('tr');
                
                // Row number
                const rowNum = document.createElement('td');
                rowNum.className = 'row-number';
                rowNum.textContent = String(row).padStart(2, '0');
                tr.appendChild(rowNum);

                // Channel cells - always display at least 16 channels (Ch1-Ch16)
                const displayChannels = Math.max(state.channels, 16);
                for (let ch = 0; ch < displayChannels; ch++) {
                    const step = pattern.channels[ch] ? pattern.channels[ch][row] : createEmptyStep();
                    const cell = createCell(row, ch, step);
                    
                    // Apply even/odd color based on base channel number
                    const trackName = state.trackNames[ch] || String(ch + 1);
                    const baseChannel = getBaseChannelNumber(trackName);
                    const isEven = isChannelEven(baseChannel);
                    cell.classList.add(isEven ? 'even' : 'odd');
                    
                    // Make first 16 channels sticky for horizontal scrolling
                    if (ch < 16) {
                        cell.style.position = 'sticky';
                        // Calculate left position: row number width (40px) + channel width (70px) * channel index
                        cell.style.left = `${40 + (ch * 70)}px`;
                        cell.style.zIndex = '10';
                    }
                    tr.appendChild(cell);
                }
                
                body.appendChild(tr);
            }

            updateActiveCell();
        }

        // Create a cell
        function createCell(row, channel, step) {
            const td = document.createElement('td');
            td.className = 'cell';
            td.dataset.row = row;
            td.dataset.channel = channel;

            const content = document.createElement('div');
            content.className = 'cell-content';

            // Note field
            const noteField = document.createElement('input');
            noteField.type = 'text';
            noteField.className = 'cell-field note-field';
            noteField.value = step.note || '';
            noteField.placeholder = '---';
            noteField.maxLength = 4;
            noteField.dataset.field = 'note';
            noteField.addEventListener('input', (e) => handleCellInput(row, channel, 'note', e.target.value));
            noteField.addEventListener('keydown', (e) => handleCellKeydown(e, row, channel));
            noteField.addEventListener('focus', () => {
                state.activeCell.row = row;
                state.activeCell.channel = channel;
                state.activeCell.field = 'note';
            });
            content.appendChild(noteField);

            // Volume field
            const volField = document.createElement('input');
            volField.type = 'text';
            volField.className = 'cell-field vol-field';
            volField.value = step.vol || '';
            volField.placeholder = '--';
            volField.maxLength = 2;
            volField.dataset.field = 'vol';
            volField.addEventListener('input', (e) => handleCellInput(row, channel, 'vol', e.target.value));
            volField.addEventListener('keydown', (e) => handleCellKeydown(e, row, channel));
            volField.addEventListener('focus', () => {
                state.activeCell.row = row;
                state.activeCell.channel = channel;
                state.activeCell.field = 'vol';
            });
            content.appendChild(volField);

            td.appendChild(content);
            return td;
        }

        // Handle cell input
        function handleCellInput(row, channel, field, value) {
            const pattern = state.patterns[state.currentPattern];
            if (!pattern.channels[channel]) {
                pattern.channels[channel] = [];
                for (let i = 0; i < state.patternLength; i++) {
                    pattern.channels[channel].push(createEmptyStep());
                }
            }
            
            if (!pattern.channels[channel][row]) {
                pattern.channels[channel][row] = createEmptyStep();
            }

            // Validate and format input
            if (field === 'note') {
                value = value.toUpperCase().replace(/[^A-G#B0-9-]/g, '');
            } else if (field === 'inst' || field === 'vol' || field === 'effect' || field === 'param') {
                value = value.replace(/[^0-9A-Fa-f]/g, '').toUpperCase();
            }

            pattern.channels[channel][row][field] = value;
            
            // Play note preview when a valid note is entered
            if (field === 'note' && value) {
                const midiNote = parseNote(value);
                if (midiNote !== null) {
                    // Get velocity from the step (or default)
                    const step = pattern.channels[channel][row];
                    const velocity = step.vol 
                        ? parseInt(step.vol, 16) * 2 
                        : 64;
                    previewNote(channel, midiNote, Math.min(127, velocity));
                }
            }
            
            savePatternsToStorage(); // Auto-save on edit
        }

        // Handle keyboard navigation in cells
        function handleCellKeydown(e, row, channel) {
            const fields = ['note', 'vol'];
            const currentField = e.target.dataset.field;
            const currentIndex = fields.indexOf(currentField);
            
            // Let QWERTY note keys pass through to global handler
            const key = e.key.toLowerCase();
            if (qwertyNoteMap[key] && currentField === 'note') {
                // Prevent default so input field doesn't capture the key
                // But don't stop propagation - let it bubble to global handler
                e.preventDefault();
                // Global handler will handle it
                return;
            }

            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                e.stopPropagation(); // Prevent global handler from also processing
                if (currentIndex > 0) {
                    // Move to previous field in same channel
                    focusField(row, channel, fields[currentIndex - 1]);
                } else {
                    // Move to previous channel (last field)
                    if (channel > 0) {
                        focusField(row, channel - 1, 'vol');
                    }
                }
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                e.stopPropagation(); // Prevent global handler from also processing
                if (currentIndex < fields.length - 1) {
                    // Move to next field in same channel
                    focusField(row, channel, fields[currentIndex + 1]);
                } else {
                    // Move to next channel (first field)
                    const maxChannel = state.channels - 1;
                    if (channel < maxChannel) {
                        focusField(row, channel + 1, 'note');
                    }
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                e.stopPropagation(); // Prevent global handler from also processing
                // Use the row from the cell, not state.activeCell.row (in case they're out of sync)
                const currentRow = parseInt(row);
                const newRow = Math.max(0, currentRow - state.stepSize);
                // Only use focusField - it handles both state update and focusing
                focusField(newRow, channel, currentField);
            } else if (e.key === 'ArrowDown' || e.key === 'Enter') {
                e.preventDefault();
                e.stopPropagation(); // Prevent global handler from also processing
                // Use the row from the cell, not state.activeCell.row (in case they're out of sync)
                const currentRow = parseInt(row);
                const newRow = Math.min(state.patternLength - 1, currentRow + state.stepSize);
                // Only use focusField - it handles both state update and focusing
                focusField(newRow, channel, currentField);
            } else if (e.key === 'Tab') {
                e.preventDefault();
                moveCell(row, channel + 1, currentField);
                focusField(row, channel + 1, currentField);
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                if (e.target.value === '') {
                    e.preventDefault();
                    clearCell(row, channel);
                }
            } else if (e.key === '.') {
                // Dot key to delete current field
                e.preventDefault();
                e.stopPropagation(); // Prevent global handler from also running
                const pattern = state.patterns[state.currentPattern];
                if (pattern && pattern.channels[channel] && pattern.channels[channel][row]) {
                    if (currentField === 'note') {
                        pattern.channels[channel][row].note = '';
                    } else if (currentField === 'vol') {
                        pattern.channels[channel][row].vol = '';
                    }
                    renderPattern();
                    // Move to next row after deleting
                    const newRow = Math.min(state.patternLength - 1, row + state.stepSize);
                    moveCell(newRow, channel, currentField);
                    focusField(newRow, channel, currentField);
                    savePatternsToStorage();
                }
                return; // Stop further processing
            } else if (e.key === '§' && currentField === 'note') {
                // § key to enter note off (==)
                e.preventDefault();
                e.stopPropagation(); // Prevent global handler from also running
                const pattern = state.patterns[state.currentPattern];
                if (!pattern.channels[channel]) {
                    pattern.channels[channel] = [];
                    for (let i = 0; i < state.patternLength; i++) {
                        pattern.channels[channel].push(createEmptyStep());
                    }
                }
                if (!pattern.channels[channel][row]) {
                    pattern.channels[channel][row] = createEmptyStep();
                }
                pattern.channels[channel][row].note = '==';
                
                // Update the display
                e.target.value = '==';
                
                // Auto-advance: move by step size
                const newRow = Math.min(state.patternLength - 1, row + state.stepSize);
                moveCell(newRow, channel, 'note');
                focusField(newRow, channel, 'note');
                savePatternsToStorage();
                return; // Stop further processing
            }
        }

        // Focus a specific field
        function focusField(row, channel, field) {
            // Ensure row, channel, and field are numbers/strings as expected
            row = parseInt(row);
            channel = parseInt(channel);
            
            // Update state first
            state.activeCell.row = row;
            state.activeCell.channel = channel;
            state.activeCell.field = field;
            
            // Update visual highlighting
            updateActiveCell();
            
            // Focus the input field
            const cell = document.querySelector(`td.cell[data-row="${row}"][data-channel="${channel}"]`);
            if (cell) {
                const input = cell.querySelector(`input[data-field="${field}"]`);
                if (input) {
                    input.focus();
                    input.select();
                    
                    // Ensure the cell is visible - scroll if needed
                    const container = document.querySelector('.pattern-editor-container');
                    if (container && channel < 16) {
                        // For channels 0-15, ensure we can scroll to see them
                        // Scroll to the beginning if we're on one of the first 16 channels
                        container.scrollLeft = 0;
                    } else if (container) {
                        // For channels beyond 16, scroll to show them
                        cell.scrollIntoView({ block: 'nearest', inline: 'nearest', behavior: 'smooth' });
                    }
                }
            }
        }

        // Move active cell
        function moveCell(row, channel, field = null) {
            row = Math.max(0, Math.min(state.patternLength - 1, row));
            // Allow navigation to all tracks (0 to state.channels - 1, max 64)
            const maxChannel = state.channels - 1;
            channel = Math.max(0, Math.min(maxChannel, channel));
            state.activeCell = { row, channel, field: field || state.activeCell.field };
            updateActiveCell();
        }

        // Centralized step navigation - handles step size correctly
        function navigateStep(direction) {
            // Get current position BEFORE any updates
            const currentRow = state.activeCell.row;
            const currentChannel = state.activeCell.channel;
            const currentField = state.activeCell.field;
            
            // Calculate new row based on direction and step size
            let newRow;
            if (direction === 'up') {
                newRow = Math.max(0, currentRow - state.stepSize);
            } else if (direction === 'down') {
                newRow = Math.min(state.patternLength - 1, currentRow + state.stepSize);
            } else {
                return; // Invalid direction
            }
            
            // Only move if the row actually changed
            if (newRow !== currentRow) {
                // Only use focusField - it handles both state update and focusing
                focusField(newRow, currentChannel, currentField);
            }
        }

        // Update active cell highlighting
        function updateActiveCell() {
            document.querySelectorAll('td.cell').forEach(cell => {
                cell.classList.remove('active');
                const row = parseInt(cell.dataset.row);
                const channel = parseInt(cell.dataset.channel);
                if (row === state.activeCell.row && channel === state.activeCell.channel) {
                    cell.classList.add('active');
                }
                if (state.isPlaying && row === state.currentStep) {
                    cell.classList.add('playing');
                } else {
                    cell.classList.remove('playing');
                }
            });

            // Scroll to active cell
            const activeCell = document.querySelector(`td.cell[data-row="${state.activeCell.row}"][data-channel="${state.activeCell.channel}"]`);
            const container = document.querySelector('.pattern-editor-container');
            if (activeCell && container) {
                if (state.activeCell.channel < 16) {
                    // For channels 0-15, scroll container to beginning to ensure Ch1-Ch16 are visible
                    container.scrollLeft = 0;
                } else {
                    // For channels beyond 16, scroll to show them
                    activeCell.scrollIntoView({ block: 'nearest', inline: 'nearest', behavior: 'smooth' });
                }
            }
        }

        // Clear cell
        function clearCell(row, channel) {
            const pattern = state.patterns[state.currentPattern];
            if (pattern.channels[channel] && pattern.channels[channel][row]) {
                pattern.channels[channel][row] = createEmptyStep();
                renderPattern();
                // Move to next row after clearing
                const newRow = Math.min(state.patternLength - 1, row + state.stepSize);
                moveCell(newRow, channel, state.activeCell.field);
                focusField(newRow, channel, state.activeCell.field);
                savePatternsToStorage();
            }
        }

        // Preview note (play a short note for feedback)
        function previewNote(channel, note, velocity = 64, duration = 150) {
            if (state.midiManager && state.midiManager.midiOutput) {
                sendMIDINote(channel, note, velocity);
                setTimeout(() => {
                    sendMIDINote(channel, note, 0, false);
                }, duration);
            }
        }

        // Enter note directly using QWERTY keyboard (Schism Tracker style)
        function enterNote(noteName, octave = null) {
            const pattern = state.patterns[state.currentPattern];
            if (!pattern.channels[state.activeCell.channel]) {
                pattern.channels[state.activeCell.channel] = [];
                for (let i = 0; i < state.patternLength; i++) {
                    pattern.channels[state.activeCell.channel].push(createEmptyStep());
                }
            }
            
            if (!pattern.channels[state.activeCell.channel][state.activeCell.row]) {
                pattern.channels[state.activeCell.channel][state.activeCell.row] = createEmptyStep();
            }

            // Format note: C#4, D3, etc.
            // Use provided octave or default to currentOctave
            const effectiveOctave = octave !== null ? octave : state.currentOctave;
            const noteStr = noteName + effectiveOctave;
            pattern.channels[state.activeCell.channel][state.activeCell.row].note = noteStr;
            
            // Update the display
            const cell = document.querySelector(`td.cell[data-row="${state.activeCell.row}"][data-channel="${state.activeCell.channel}"]`);
            if (cell) {
                const noteField = cell.querySelector('input[data-field="note"]');
                if (noteField) {
                    noteField.value = noteStr;
                }
            }

            // Play note preview
            const midiNote = parseNote(noteStr);
            if (midiNote !== null) {
                const step = pattern.channels[state.activeCell.channel][state.activeCell.row];
                const velocity = step.vol 
                    ? parseInt(step.vol, 16) * 2 
                    : 64;
                previewNote(state.activeCell.channel, midiNote, Math.min(127, velocity), 150);
            }

            // Auto-advance: move by step size (like Schism Tracker)
            const newRow = state.activeCell.row + state.stepSize;
            moveCell(newRow, state.activeCell.channel, 'note');
            focusField(newRow, state.activeCell.channel, 'note');
            savePatternsToStorage();
        }

        // Enter hex value in current field
        function enterHexValue(value) {
            const pattern = state.patterns[state.currentPattern];
            if (!pattern.channels[state.activeCell.channel]) {
                pattern.channels[state.activeCell.channel] = [];
                for (let i = 0; i < state.patternLength; i++) {
                    pattern.channels[state.activeCell.channel].push(createEmptyStep());
                }
            }
            
            if (!pattern.channels[state.activeCell.channel][state.activeCell.row]) {
                pattern.channels[state.activeCell.channel][state.activeCell.row] = createEmptyStep();
            }

            const field = state.activeCell.field;
            const currentValue = pattern.channels[state.activeCell.channel][state.activeCell.row][field] || '';
            
            // Vol field: two hex digits - append or replace
            let newValue;
            if (currentValue.length >= 2) {
                newValue = value.toUpperCase();
            } else {
                newValue = (currentValue + value).toUpperCase().padStart(2, '0');
            }

            pattern.channels[state.activeCell.channel][state.activeCell.row][field] = newValue;
            
            // Update the display
            const cell = document.querySelector(`td.cell[data-row="${state.activeCell.row}"][data-channel="${state.activeCell.channel}"]`);
            if (cell) {
                const fieldInput = cell.querySelector(`input[data-field="${field}"]`);
                if (fieldInput) {
                    fieldInput.value = newValue;
                }
            }

            // Auto-advance: after vol, move by step size
            if (field === 'vol') {
                const currentRow = state.activeCell.row;
                const newRow = Math.min(state.patternLength - 1, currentRow + state.stepSize);
                moveCell(newRow, state.activeCell.channel, 'note');
                focusField(newRow, state.activeCell.channel, 'note');
            } else {
                // Move to vol field
                focusField(state.activeCell.row, state.activeCell.channel, 'vol');
                state.activeCell.field = 'vol';
            }
            savePatternsToStorage();
        }

        // Precise MIDI clock ticker
        function scheduleMidiClock() {
            if (!state.isPlaying) return;
            
            const now = performance.now();
            
            // MIDI Clock: 24 ticks per quarter note
            // Clock interval = 60000ms / BPM / 24 ticks per quarter note
            // More precise calculation: (60 * 1000) / (BPM * 24)
            const midiClockInterval = (60000.0 / state.bpm / 24.0);
            
            // Calculate when the next clock tick should happen
            if (state.scheduledMidiClockTime === 0) {
                state.scheduledMidiClockTime = now + midiClockInterval;
            } else {
                // Schedule next tick based on when it should have happened, not when we check
                // This prevents drift accumulation
                state.scheduledMidiClockTime += midiClockInterval;
            }
            
            // Calculate delay, but if we're behind, catch up immediately
            const delay = Math.max(0, Math.min(midiClockInterval, state.scheduledMidiClockTime - now));
            
            // Use the most precise timing available
            state.midiClockTimer = setTimeout(() => {
                if (state.isPlaying) {
                    sendMIDIClock();
                    scheduleMidiClock();
                }
            }, delay);
        }

        // Precise step scheduler
        function scheduleStep() {
            if (!state.isPlaying) return;
            
            const now = performance.now();
            
            // BPM-based timing: 4 steps per beat (16th notes)
            // Step interval = 60000ms / BPM / 4 steps per beat
            // More precise calculation: (60 * 1000) / (BPM * 4)
            const stepInterval = (60000.0 / state.bpm / 4.0);
            
            // Calculate when the next step should happen
            if (state.scheduledStepTime === 0) {
                state.scheduledStepTime = now + stepInterval;
            } else {
                // Schedule next step based on when it should have happened, not when we check
                // This prevents drift accumulation
                state.scheduledStepTime += stepInterval;
            }
            
            // Calculate delay, but if we're behind, catch up immediately
            const delay = Math.max(0, Math.min(stepInterval, state.scheduledStepTime - now));
            
            // Use the most precise timing available
            state.stepTimer = setTimeout(() => {
                if (state.isPlaying) {
                    playStep();
                    scheduleStep();
                }
            }, delay);
        }

        function playStep() {
            const pattern = state.patterns[state.currentPattern];
            if (!pattern) return;

            // Process current step - process all tracks (up to 64)
            for (let ch = 0; ch < state.channels; ch++) {
                if (!pattern.channels[ch]) continue;
                const step = pattern.channels[ch][state.currentStep];
                if (!step) continue;

                // Get MIDI channel for this track
                const midiChannel = state.trackMidiChannels[ch] !== undefined 
                    ? Math.min(state.trackMidiChannels[ch], 15)
                    : Math.min(ch, 15);

                // Send program change if this is the first step and we have a stored program change
                if (state.currentStep === 0 && state.midiProgramChanges[midiChannel] !== undefined) {
                    sendMIDIProgramChange(midiChannel, state.midiProgramChanges[midiChannel]);
                }

                // Stop previous note if new note or note off
                const noteKey = `${ch}-${state.currentStep}`;
                
                if (state.activeNotes.has(noteKey)) {
                    const activeNote = state.activeNotes.get(noteKey);
                    sendMIDINote(ch, activeNote.note, 0, false);
                    state.activeNotes.delete(noteKey);
                }

                // Parse and play note
                if (step.note && step.note.trim() !== '') {
                    // Check for note off marker (==)
                    if (step.note.trim() === '==') {
                        // Send note off for all active notes on this track
                        state.activeNotes.forEach((activeNote, key) => {
                            if (activeNote.track === ch) {
                                sendMIDINote(ch, activeNote.note, 0, false);
                                state.activeNotes.delete(key);
                            }
                        });
                    } else {
                        const midiNote = parseNote(step.note);
                        // Validate note is within valid MIDI range (0-127)
                        if (midiNote !== null && midiNote >= 0 && midiNote <= 127) {
                            // Send note off for all active notes on this track before playing new note
                            state.activeNotes.forEach((activeNote, key) => {
                                if (activeNote.track === ch) {
                                    sendMIDINote(ch, activeNote.note, 0, false);
                                    state.activeNotes.delete(key);
                                }
                            });
                            
                            const velocity = step.vol ? parseInt(step.vol, 16) * 2 : 64;
                            const clampedVelocity = Math.min(127, velocity);
                            
                            sendMIDINote(ch, midiNote, clampedVelocity);
                            state.activeNotes.set(noteKey, { note: midiNote, track: ch });
                        }
                    }
                }
            }

            // Update visual
            updateActiveCell();

            // Advance step
            state.currentStep++;
            if (state.currentStep >= state.patternLength) {
                state.currentStep = 0;
                
                if (state.playbackMode === 'pattern') {
                    // Pattern mode: loop current pattern
                    // No pattern change needed
                } else {
                    // Song mode: advance to next pattern in order
                    const orderIndex = state.order.indexOf(state.currentPattern);
                    if (orderIndex >= 0 && orderIndex < state.order.length - 1) {
                        state.currentPattern = state.order[orderIndex + 1];
                    } else {
                        // Loop back to first pattern in order
                        state.currentPattern = state.order[0];
                    }
                    document.getElementById('patternInput').value = state.currentPattern;
                    renderPattern();
                    updatePatternOrder();
                }
            }

            document.getElementById('currentStep').textContent = state.currentStep;
        }

        // Handle effect commands

        // Start playback
        async function startPlayback() {
            if (state.isPlaying) return;
            
            // Ensure MIDI is initialized
            if (!state.midiManager) {
                await requestMIDIAccess();
            } else if (!state.midiManager.isConnected()) {
                // Try to reconnect if not connected
                const devices = state.midiManager.getDevices();
                if (devices.length > 0) {
                    state.midiManager.connect(0);
                    state.midiOutput = state.midiManager.midiOutput;
                }
            }
            
            state.isPlaying = true;
            state.currentStep = 0;
            const now = performance.now();
            state.lastTickTime = now;
            state.lastMidiClockTime = now;
            state.midiClockCounter = 0;
            state.scheduledMidiClockTime = 0;
            state.scheduledStepTime = 0;
            
            // Send MIDI Start message
            sendMIDIStart();
            
            document.getElementById('playBtn').classList.add('active');
            
            // Start precise timing schedulers
            scheduleMidiClock();
            scheduleStep();
        }

        // Stop playback
        function stopPlayback() {
            state.isPlaying = false;
            state.currentStep = 0;
            document.getElementById('playBtn').classList.remove('active');
            
            // Clear timers
            if (state.midiClockTimer) {
                clearTimeout(state.midiClockTimer);
                state.midiClockTimer = null;
            }
            if (state.stepTimer) {
                clearTimeout(state.stepTimer);
                state.stepTimer = null;
            }
            
            // Reset scheduled times
            state.scheduledMidiClockTime = 0;
            state.scheduledStepTime = 0;
            
            // Send MIDI Stop message
            sendMIDIStop();
            
            // Stop all active notes
            state.activeNotes.forEach((note, key) => {
                sendMIDINote(note.channel, note.note, 0, false);
            });
            state.activeNotes.clear();
            
            document.getElementById('currentStep').textContent = state.currentStep;
            updateActiveCell();
        }


        // Update pattern order display
        function updatePatternOrder() {
            const orderDiv = document.getElementById('patternOrder');
            orderDiv.innerHTML = '';
            state.order.forEach((patternIndex, index) => {
                const item = document.createElement('div');
                item.className = 'pattern-order-item';
                if (patternIndex === state.currentPattern) {
                    item.classList.add('active');
                }
                item.textContent = patternIndex;
                item.addEventListener('click', () => {
                    state.currentPattern = patternIndex;
                    document.getElementById('patternInput').value = patternIndex;
                    renderPattern();
                    updatePatternOrder();
                    savePatternsToStorage();
                });
                orderDiv.appendChild(item);
            });
        }

        // Update pattern quick switch buttons
        function updatePatternQuickSwitch() {
            const quickSwitch = document.getElementById('patternQuickSwitch');
            if (!quickSwitch) return;
            
            quickSwitch.innerHTML = '';
            // Show up to 8 pattern buttons
            const maxButtons = Math.min(8, state.patterns.length);
            for (let i = 0; i < maxButtons; i++) {
                const btn = document.createElement('button');
                btn.className = 'pattern-quick-btn';
                btn.textContent = i;
                if (i === state.currentPattern) {
                    btn.classList.add('active');
                }
                btn.title = `Pattern ${i} (Ctrl+${i + 1})`;
                btn.addEventListener('click', () => {
                    if (i < state.patterns.length) {
                        state.currentPattern = i;
                        document.getElementById('patternInput').value = i;
                        renderPattern();
                        updatePatternOrder();
                        savePatternsToStorage();
                    }
                });
                quickSwitch.appendChild(btn);
            }
        }


        // Add pattern
        function addPattern() {
            const pattern = {
                channels: []
            };
            for (let ch = 0; ch < state.channels; ch++) {
                const channel = [];
                for (let row = 0; row < state.patternLength; row++) {
                    channel.push(createEmptyStep());
                }
                pattern.channels.push(channel);
            }
            const newPatternIndex = state.patterns.length;
            state.patterns.push(pattern);
            state.order.push(state.patterns.length - 1);
            updatePatternOrder();
            updatePatternQuickSwitch();
            savePatternsToStorage();
        }


        // Enhanced keyboard shortcuts (Schism Tracker style)
        document.addEventListener('keydown', (e) => {
            // Don't intercept if user is typing in header inputs
            if (e.target.tagName === 'INPUT' && (e.target.id === 'bpmInput' || e.target.id === 'patternInput')) {
                return;
            }

            const isCellInput = e.target.tagName === 'INPUT' && e.target.closest('td.cell');
            const key = e.key.toLowerCase();

            // QWERTY note entry (Schism Tracker style) - check this FIRST
            // Always allow QWERTY note entry when in note field or when not actively typing
            if (qwertyNoteMap[key] && !e.ctrlKey && !e.altKey && !e.metaKey) {
                // Only allow if we're in note field, or if we're not in a cell input
                if (state.activeCell.field === 'note' || !isCellInput) {
                    e.preventDefault();
                    e.stopPropagation();
                    // Blur the input field if focused, so it doesn't capture the key
                    if (isCellInput && document.activeElement) {
                        document.activeElement.blur();
                    }
                    const noteName = qwertyNoteMap[key];
                    // Determine octave offset based on key row (Schism Tracker style)
                    // Z row (bottom): base octave, Q row (top): +1, I row: +2
                    let octaveOffset = 0;
                    if (['q', '2', 'w', '3', 'e', 'r', '5', 't', '6', 'y', '7', 'u'].includes(key)) {
                        octaveOffset = 1; // Q row = one octave up
                    } else if (['i', '9', 'o', '0', 'p', '[', '=', ']'].includes(key)) {
                        octaveOffset = 2; // I row = two octaves up
                    }
                    // Use current octave + offset, clamped to 0-9
                    const effectiveOctave = Math.max(0, Math.min(9, state.currentOctave + octaveOffset));
                    enterNote(noteName, effectiveOctave);
                    // Note preview is handled inside enterNote()
                    return;
                }
            }

            // / and * keys for octave decrease/increase (Schism Tracker style)
            if ((key === '/' || key === '*') && !e.ctrlKey && !e.altKey && !e.metaKey) {
                if (state.activeCell.field === 'note' || !isCellInput) {
                    e.preventDefault();
                    if (key === '/') {
                        // Decrease octave
                        state.currentOctave = Math.max(0, state.currentOctave - 1);
                    } else if (key === '*') {
                        // Increase octave
                        state.currentOctave = Math.min(9, state.currentOctave + 1);
                    }
                    updateOctaveDisplay();
                    return;
                }
            }

            // Number keys for octave selection
            if (key >= '0' && key <= '9' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                if (state.activeCell.field === 'note' || !isCellInput) {
                    e.preventDefault();
                    const octave = parseInt(key);
                    // If we just entered a note, append octave; otherwise set octave for next note
                    const pattern = state.patterns[state.currentPattern];
                    const step = pattern.channels[state.activeCell.channel]?.[state.activeCell.row];
                    if (step && step.note && step.note.match(/^[A-G][#]?$/)) {
                        // Append octave to existing note
                        step.note = step.note + octave;
                        const cell = document.querySelector(`td.cell[data-row="${state.activeCell.row}"][data-channel="${state.activeCell.channel}"]`);
                        if (cell) {
                            const noteField = cell.querySelector('input[data-field="note"]');
                            if (noteField) noteField.value = step.note;
                        }
                        const currentRow = state.activeCell.row;
                        const newRow = Math.min(state.patternLength - 1, currentRow + state.stepSize);
                        moveCell(newRow, state.activeCell.channel, 'note');
                        focusField(newRow, state.activeCell.channel, 'note');
                    } else {
                        // Set octave for next note entry
                        state.currentOctave = octave;
                        updateOctaveDisplay();
                    }
                    return;
                }
            }

            // ESC key to close modal
            if (e.key === 'Escape') {
                const instrumentModal = document.getElementById('instrumentModal');
                const programModal = document.getElementById('programChangeModal');
                if (instrumentModal && instrumentModal.style.display === 'block') {
                    e.preventDefault();
                    closeInstrumentModal();
                    return;
                }
                if (programModal && programModal.style.display === 'block') {
                    e.preventDefault();
                    closeProgramChangeModal();
                    return;
                }
            }

            // Arrow keys - handle navigation when not in cell inputs
            // (Cell inputs handle their own navigation and stop propagation)
            if (!isCellInput) {
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    navigateStep('up');
                    return;
                } else if (e.key === 'ArrowDown' || e.key === 'Enter') {
                    e.preventDefault();
                    navigateStep('down');
                    return;
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    const fields = ['note', 'vol'];
                    const currentIndex = fields.indexOf(state.activeCell.field);
                    if (currentIndex > 0) {
                        // Move to previous field in same channel
                        focusField(state.activeCell.row, state.activeCell.channel, fields[currentIndex - 1]);
                    } else {
                        // Move to previous channel (last field)
                        if (state.activeCell.channel > 0) {
                            focusField(state.activeCell.row, state.activeCell.channel - 1, 'vol');
                        }
                    }
                    return;
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    const fields = ['note', 'vol'];
                    const currentIndex = fields.indexOf(state.activeCell.field);
                    if (currentIndex < fields.length - 1) {
                        // Move to next field in same channel
                        focusField(state.activeCell.row, state.activeCell.channel, fields[currentIndex + 1]);
                    } else {
                        // Move to next channel (first field)
                        if (state.activeCell.channel < state.channels - 1) {
                            focusField(state.activeCell.row, state.activeCell.channel + 1, 'note');
                        }
                    }
                    return;
                }
            }

            // Alt+[number] to set step size
            if (e.altKey && !e.ctrlKey && !e.metaKey && key >= '0' && key <= '9') {
                e.preventDefault();
                const stepSize = parseInt(key);
                if (stepSize >= 1 && stepSize <= 64) {
                    state.stepSize = stepSize;
                    document.getElementById('stepSizeInput').value = stepSize;
                    savePatternsToStorage();
                }
                return;
            }

            // Dot key to delete current field (note or vol) - only when not typing in cell input
            if (e.key === '.' && !e.ctrlKey && !e.altKey && !e.metaKey && !isCellInput) {
                e.preventDefault();
                const pattern = state.patterns[state.currentPattern];
                if (pattern && pattern.channels[state.activeCell.channel] && pattern.channels[state.activeCell.channel][state.activeCell.row]) {
                    const field = state.activeCell.field;
                    if (field === 'note') {
                        pattern.channels[state.activeCell.channel][state.activeCell.row].note = '';
                    } else if (field === 'vol') {
                        pattern.channels[state.activeCell.channel][state.activeCell.row].vol = '';
                    }
                    renderPattern();
                    // Move to next row after deleting
                    const currentRow = state.activeCell.row;
                    const newRow = Math.min(state.patternLength - 1, currentRow + state.stepSize);
                    moveCell(newRow, state.activeCell.channel, field);
                    focusField(newRow, state.activeCell.channel, field);
                    savePatternsToStorage();
                }
                return;
            }

            // § key to enter note off (==) - only when not typing in cell input
            if (e.key === '§' && state.activeCell.field === 'note' && !e.ctrlKey && !e.altKey && !e.metaKey && !isCellInput) {
                e.preventDefault();
                const pattern = state.patterns[state.currentPattern];
                if (!pattern.channels[state.activeCell.channel]) {
                    pattern.channels[state.activeCell.channel] = [];
                    for (let i = 0; i < state.patternLength; i++) {
                        pattern.channels[state.activeCell.channel].push(createEmptyStep());
                    }
                }
                if (!pattern.channels[state.activeCell.channel][state.activeCell.row]) {
                    pattern.channels[state.activeCell.channel][state.activeCell.row] = createEmptyStep();
                }
                pattern.channels[state.activeCell.channel][state.activeCell.row].note = '==';
                
                // Update the display
                const cell = document.querySelector(`td.cell[data-row="${state.activeCell.row}"][data-channel="${state.activeCell.channel}"]`);
                if (cell) {
                    const noteField = cell.querySelector('input[data-field="note"]');
                    if (noteField) {
                        noteField.value = '==';
                    }
                }
                
                // Auto-advance: move by step size
                const currentRow = state.activeCell.row;
                const newRow = currentRow + state.stepSize;
                moveCell(newRow, state.activeCell.channel, 'note');
                focusField(newRow, state.activeCell.channel, 'note');
                savePatternsToStorage();
                return;
            }

            // Hex digit entry for volume
            if (/[0-9A-Fa-f]/.test(key) && state.activeCell.field === 'vol') {
                if (!isCellInput) {
                    e.preventDefault();
                    enterHexValue(key);
                }
                return;
            }

            // Control keys - Play/Stop
            // Only handle if not typing in a cell input (unless it's Space, which should always work)
            if (e.key === ' ') {
                // Space for play/stop toggle (always works)
                e.preventDefault();
                if (state.isPlaying) {
                    stopPlayback();
                } else {
                    startPlayback();
                }
                return;
            } else if ((key === 'p' || key === 's') && !e.ctrlKey && !e.altKey && !e.metaKey && !isCellInput) {
                // P for play/stop toggle, S for stop (only when not typing in cells)
                e.preventDefault();
                if (key === 'p') {
                    // P: Play/Stop toggle
                    if (state.isPlaying) {
                        stopPlayback();
                    } else {
                        startPlayback();
                    }
                } else if (key === 's') {
                    // S: Stop only
                    if (state.isPlaying) {
                        stopPlayback();
                    }
                }
                return;
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                if (!isCellInput || e.target.value === '') {
                    e.preventDefault();
                    clearCell(state.activeCell.row, state.activeCell.channel);
                }
                return;
            } else if (e.ctrlKey && key === 'c') {
                e.preventDefault();
                copyCell();
                return;
            } else if (e.ctrlKey && key === 'v') {
                e.preventDefault();
                pasteCell();
                return;
            } else if (e.ctrlKey && (key === 'i' || key === 'I')) {
                // Ctrl+I: Open program change dialog for current MIDI channel
                e.preventDefault();
                openProgramChangeModal();
                return;
            } else if (e.ctrlKey && (e.key === '+' || e.key === '=')) {
                // Ctrl++: Add additional track for current MIDI channel
                e.preventDefault();
                addTrackForCurrentChannel();
                return;
            } else if (e.ctrlKey && (e.key === '-' || e.key === '_')) {
                // Ctrl+-: Remove additional track (tracks with suffixes like 4b, 4c)
                e.preventDefault();
                removeTrackWithSuffix();
                return;
            } else if (e.key === 'Tab') {
                e.preventDefault();
                moveCell(state.activeCell.row, state.activeCell.channel + 1, state.activeCell.field);
                focusField(state.activeCell.row, state.activeCell.channel, state.activeCell.field);
                return;
            } else if (e.ctrlKey && key >= '1' && key <= '8') {
                // Ctrl+1-8 for pattern switching (browser-friendly alternative to F1-F8)
                e.preventDefault();
                const num = parseInt(key) - 1;
                if (num >= 0 && num < state.patterns.length) {
                    state.currentPattern = num;
                    document.getElementById('patternInput').value = state.currentPattern;
                    renderPattern();
                    updatePatternOrder();
                }
                return;
            } else if (e.ctrlKey && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                // Ctrl+Left/Right for previous/next pattern
                e.preventDefault();
                const currentIndex = state.order.indexOf(state.currentPattern);
                if (e.key === 'ArrowLeft') {
                    // Previous pattern in order
                    if (currentIndex > 0) {
                        state.currentPattern = state.order[currentIndex - 1];
                    } else {
                        state.currentPattern = state.order[state.order.length - 1];
                    }
                } else {
                    // Next pattern in order
                    if (currentIndex < state.order.length - 1) {
                        state.currentPattern = state.order[currentIndex + 1];
                    } else {
                        state.currentPattern = state.order[0];
                    }
                }
                document.getElementById('patternInput').value = state.currentPattern;
                renderPattern();
                updatePatternOrder();
                updatePatternQuickSwitch();
                return;
            }
        });

        // Copy/paste
        function copyCell() {
            const pattern = state.patterns[state.currentPattern];
            if (pattern.channels[state.activeCell.channel]) {
                state.clipboard = pattern.channels[state.activeCell.channel][state.activeCell.row];
            }
        }

        function pasteCell() {
            if (!state.clipboard) return;
            const pattern = state.patterns[state.currentPattern];
            if (!pattern.channels[state.activeCell.channel]) {
                pattern.channels[state.activeCell.channel] = [];
                for (let i = 0; i < state.patternLength; i++) {
                    pattern.channels[state.activeCell.channel].push(createEmptyStep());
                }
            }
            pattern.channels[state.activeCell.channel][state.activeCell.row] = { ...state.clipboard };
            renderPattern();
            moveCell(state.activeCell.row, state.activeCell.channel, state.activeCell.field);
            savePatternsToStorage();
        }

        // Event listeners
        document.getElementById('playBtn').addEventListener('click', startPlayback);
        document.getElementById('stopBtn').addEventListener('click', stopPlayback);
        document.getElementById('addPatternBtn').addEventListener('click', addPattern);
        
        // Octave input field
        document.getElementById('octaveInput').addEventListener('change', (e) => {
            const octave = parseInt(e.target.value);
            if (!isNaN(octave) && octave >= 0 && octave <= 9) {
                state.currentOctave = octave;
                updateOctaveDisplay();
                savePatternsToStorage();
            }
        });
        
        // Step size input field
        document.getElementById('stepSizeInput').addEventListener('change', (e) => {
            const stepSize = parseInt(e.target.value);
            if (!isNaN(stepSize) && stepSize >= 1 && stepSize <= 64) {
                state.stepSize = stepSize;
                savePatternsToStorage();
            }
        });
        
        // Pattern length input field
        document.getElementById('patternLengthInput').addEventListener('change', (e) => {
            const length = parseInt(e.target.value);
            if (!isNaN(length) && length >= 1 && length <= 256) {
                const oldLength = state.patternLength;
                state.patternLength = length;
                
                // Resize all patterns
                resizeAllPatterns();
                
                // If current step is beyond new length, reset to 0
                if (state.currentStep >= state.patternLength) {
                    state.currentStep = 0;
                }
                
                // Re-render pattern
                renderPattern();
                savePatternsToStorage();
            } else {
                // Reset to valid value if invalid
                e.target.value = state.patternLength;
            }
        });
        
        // Play mode selector
        document.getElementById('playModeSelect').addEventListener('change', (e) => {
            state.playbackMode = e.target.value;
            savePatternsToStorage();
        });
        

        document.getElementById('bpmInput').addEventListener('input', (e) => {
            const newBpm = parseInt(e.target.value) || 125;
            const wasPlaying = state.isPlaying;
            
            // If playing, restart timing with new BPM
            if (wasPlaying) {
                stopPlayback();
                state.bpm = newBpm;
                startPlayback();
            } else {
                state.bpm = newBpm;
            }
        });

        document.getElementById('patternInput').addEventListener('input', (e) => {
            const patternIndex = parseInt(e.target.value) || 0;
            if (patternIndex >= 0 && patternIndex < state.patterns.length) {
                state.currentPattern = patternIndex;
                renderPattern();
                updatePatternOrder();
                updatePatternQuickSwitch();
                savePatternsToStorage();
            }
        });

        // Initialize
        // Initialize step size input
        document.getElementById('stepSizeInput').value = state.stepSize;
        
        // Try to load patterns from storage
        const patternsLoaded = loadPatternsFromStorage();
        
        // If no patterns were loaded, create default pattern
        if (!patternsLoaded) {
            // Ensure pattern 0 exists and has 16 channels
            if (!state.patterns[0] || state.patterns[0].channels.length < state.channels) {
                initPattern(0);
                // Ensure it has all 16 channels
                const pattern = state.patterns[0];
                while (pattern.channels.length < state.channels) {
                    const channel = [];
                    for (let row = 0; row < state.patternLength; row++) {
                        channel.push(createEmptyStep());
                    }
                    pattern.channels.push(channel);
                }
            }
            // Save initial patterns
            savePatternsToStorage();
        } else {
            // Ensure all loaded patterns have 16 channels
            state.patterns.forEach((pattern, index) => {
                while (pattern.channels.length < 16) {
                    const channel = [];
                    for (let row = 0; row < state.patternLength; row++) {
                        channel.push(createEmptyStep());
                    }
                    pattern.channels.push(channel);
                }
            });
        }
        
        // Force all patterns to have exactly 16 channels (in case they had more or less)
        state.patterns.forEach((pattern) => {
            // Remove excess channels if any
            if (pattern.channels.length > 16) {
                pattern.channels = pattern.channels.slice(0, 16);
            }
            // Add missing channels
            while (pattern.channels.length < 16) {
                const channel = [];
                for (let row = 0; row < state.patternLength; row++) {
                    channel.push(createEmptyStep());
                }
                pattern.channels.push(channel);
            }
        });
        
        // Always use MIDI - initialize MIDI access on page load
        requestMIDIAccess().catch(err => {
            console.warn('MIDI initialization failed:', err);
        });
        
        renderPattern();
        updatePatternOrder();
        document.getElementById('bpmInput').value = state.bpm;
        document.getElementById('playModeSelect').value = state.playbackMode;
        updateOctaveDisplay();
        
        // Focus the editor on load
        setTimeout(() => {
            focusField(0, 0, 'note');
        }, 100);
    </script>
</body>
</html>

